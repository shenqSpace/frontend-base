/**
 * 4.2.2 变量声明
 */

/**
 * 1.使用var的函数作用域声明
 * var声明会被拿到函数或全局作用域的顶部,位于作用域中所有代码之前.这个现象叫作"提升"
 */
function add(n1, n2) {
    // total未经声明就被初始化,一旦函数被调用,total会自动添加到全局上下文中
    total = n1 + n2;
    return total;
}

console.log(add(1, 2));
console.log(total);

/**
 * 2.使用let的块级作用域声明
 * ES6 新增的 let 关键字跟 var 很相似，但它的作用域是块级的，这也是 JavaScript 中的新概念。
 * 块级作用域由最近的一对包含花括号{}界定。换句话说，if 块、while 块、function 块，
 * 甚至连单独的块也是 let 声明变量的作用域。
 */

//在循环中,var声明的迭代变量会泄漏到循环外部,但let不会
for (let x = 0; x <= 10; x++) {
    // let声明的变量是块作用域,所以只在当前for循环块中作局部变量,不会被外部使用
}

for (var x = 0; x <= 10; x++) {
    //var声明的x的作用域不是块作用域,在这里是全局作用域,因此全局上下文可以调用这个变量
}

/**
 * 3.使用const的常量声明
 * 由于const声明暗示变量的值是单一类型且不可修改,JS运行时编译器可以将其所有实例都替换成实际的值,
 * 而不会通过查询表进行变量查找.谷歌的V8引擎执行这种优化
 */


/**
 * 4.标识符查找
 * 当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。
 * 搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，
 * 则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。
 * (注意，作用域链中的对象也有一个 原型链，因此搜索可能涉及每个对象的原型链。)
 * 这个过程一直持续到搜索至全局上下文的变量对象。 如果仍然没有找到标识符，则说明其未声明。
 */
